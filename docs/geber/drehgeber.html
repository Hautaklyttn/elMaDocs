


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xml:lang="" lang="" version="-//W3C//DTD XHTML 1.1//EN" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="">
    <link rel="icon" type="image/x-icon" href="">

  
  <title>Drehgeber &mdash; elMaDocs</title>
  

  

  

    <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'/>


  <link rel="stylesheet" href="../_static/css/img.css" type="text/css"/>
  
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/css/pdj.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/styleConfig.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/hacks.css" type="text/css" />
  

  

  <link rel="stylesheet" href="../_static/css/darker.css" type="text/css" media="(prefers-color-scheme: dark)"/>
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="elMaDocs" href="../index.html"/>
        <link rel="next" title="LabView" href="../grundlagen/labview.html"/>
        <link rel="prev" title="Weitere Motortypen" href="../motoren/weitMot.html"/>

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="cache-control" content="public" />
    <meta name="robots" content="follow, all" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Add jQuery library -->
    <script type="text/javascript" src="https://code.jquery.com/jquery-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>
    <script type="module" src="https://googlechromelabs.github.io/dark-mode-toggle/src/dark-mode-toggle.mjs"></script>

  </head>

  <body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
	
	
        <div role="search">
	  
	  <form id ="rtd-search-form" class="wy-form"
		action="../search.html" method="get">
	    <input type="text" name="q" placeholder="Search docs" />
	    <input type="hidden" name="check_keywords" value="yes" />
	    <input type="hidden" name="area" value="default" />
	  </form>
	  
	</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	
          
          
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../grundlagen/grundlagen.html">Grundlagen</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../grundlagen/grundlagen.html#das-magnetische-feld">Das magnetische Feld</a></li>
<li class="toctree-l2"><a class="reference internal" href="../grundlagen/grundlagen.html#die-magnetischen-grundgroszen">Die magnetischen Grundgrößen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../grundlagen/grundlagen.html#drehstrom-oder-gleichstrom">Drehstrom oder Gleichstrom?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../grundlagen/grundlagen.html#was-wird-wo-eingesetzt">Was wird wo eingesetzt?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../grundlagen/grundlagen.html#merksatze">Merksätze</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../motoren/dcMot.html">Gleichstrommaschine</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../motoren/dcMot.html#uberblick">Überblick</a></li>
<li class="toctree-l2"><a class="reference internal" href="../motoren/dcMot.html#der-stander">Der Ständer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../motoren/dcMot.html#der-laufer">Der Läufer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../motoren/dcMot.html#die-wirkungsweise">Die Wirkungsweise</a></li>
<li class="toctree-l2"><a class="reference internal" href="../motoren/dcMot.html#schaltungsarten">Schaltungsarten</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../motoren/syncMot.html">Synchronmaschine</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../motoren/syncMot.html#permantenterregte-synchronmaschine">Permantenterregte Synchronmaschine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../motoren/syncMot.html#fremderregte-synchronmaschine">Fremderregte Synchronmaschine</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../motoren/asyncMot.html">Asynchronmaschine</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../motoren/asyncMot.html#aufbau">Aufbau</a></li>
<li class="toctree-l2"><a class="reference internal" href="../motoren/asyncMot.html#eigenschaften">Eigenschaften</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../motoren/weitMot.html">Weitere Motortypen</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../motoren/weitMot.html#synchron-reluktanzmotor">Synchron-Reluktanzmotor</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Drehgeber</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#aufbau">Aufbau</a></li>
<li class="toctree-l2"><a class="reference internal" href="#winkel-drehzahl-und-winkelbeschleunigung">Winkel, Drehzahl und Winkelbeschleunigung</a></li>
<li class="toctree-l2"><a class="reference internal" href="#messbereich">Messbereich</a></li>
<li class="toctree-l2"><a class="reference internal" href="#winkelberechnung">Winkelberechnung</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kodierung">Kodierung</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../grundlagen/labview.html">LabView</a></li>
</ul>

          
        

      </div>
      &nbsp;
    </nav>
    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      <nav class="wy-nav-top" id="barra-mobile" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="#">elMaDocs </a>
      </nav>

      <div class="wy-nav-content">
	<div class="fundo-claro">
	</div>
	<div class="fundo-escuro">
	</div>

        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
	    
	    <!-- <ul class="wy-breadcrumbs"> -->
	    <!--   <li><a href="#">Docs</a> &raquo;</li> -->

	    <!--   <li>Features</li> -->
	    <!--   <li class="wy-breadcrumbs-aside"> -->

	    <!-- 	<a href="_sources/index.txt" rel="nofollow"> View page source</a> -->

	    <!--   </li> -->
	    <!-- </ul> -->
	    <!-- <hr/> -->
	  </div>
          <div role="main" class="">

	    <div id="content" class="hfeed entry-container hentry">
      	<div id="dark-mode-toggle-container">
	  <dark-mode-toggle appearance="toggle" dark="switch to light mode" light="switch to dark mode">
	  </dark-mode-toggle>
	</div>
  <section id="drehgeber">
<h1>Drehgeber<a class="headerlink" href="#drehgeber" title="Link to this heading">¶</a></h1>
<font size="-2">(Quelle ist hauptsächlich S.Balser - "Encoder und Motor-Feedback-Systeme")</font><hr class="docutils" />
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Nahezu überall, wo etwas bewegt wird, drehen sich Achsen. Um diese rotatorische Bewegung <span class="navy">steuern und regeln</span> zu können, bedarf es Encoder und Motor-Feedback-Systeme. Diese wandeln den Winkel zweier relativ zueinander drehbarer Objekte in ein elektrisches Signal um. Encoder und Motor-Feedback-Systeme unterscheiden sich dabei primär in der Anwendung und sich daraus ergebenden Geräteanforderungen.</p>
<p><span class="navy">Encoder</span> (Lagegeber) werden im Allgemeinen zur Erfassung eines Winkels einer Drehachse verwendet.</p>
<p><span class="navy">Motor-Feedback-Systeme</span> (Motorgeber) sind speziell für den Einsatz in Elektromotoren ausgelegt.</p>
<p>Man kann auch unterscheiden, dass ein Encoder als <span class="navy">Lastgeber</span> dient (er misst an der Lastachse) und ein Motor-Feedback-System als <span class="navy">Motorgeber</span> (es ist direkt im oder am Elektromotor angebracht).</p>
<p>Allgmein wird bevorzugt der Begriff <span class="navy">Drehgeber</span> verwendet, da es sich um allgemeine Darstellungen handelt.</p>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<section id="aufbau">
<h2>Aufbau<a class="headerlink" href="#aufbau" title="Link to this heading">¶</a></h2>
<p>Der Sensorkern eines Drehgebers besteht grundsätzlich aus drei Elementen (s.Bild unten). Der <span class="navy">Sender</span> bringt Energie in das System ein. Der <span class="navy">Modulator</span> verändert die eingebrachte Energie proportional zum mechanischen Winkel φ und dient somit als Maßverkörperung. Der <span class="navy">Empfänger</span> wandelt die modulierte physikalische Größe in ein elektrisches Signal. Kombiniert mit Signalverarbeitung, elektrischer und mechanischer Anbindung erhält man einen Drehgeber.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<a class="reference internal image-reference" href="../_images/funcBlocks.png"><img alt="../_images/funcBlocks.png" src="../_images/funcBlocks.png" style="width: 520px;" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Diese abstrakte Betrachtungsweise hinsichtlich Sender-Modulator-Empfänger lässt sich mittels unterschiedlicher sensorischer Prinzipien umsetzen. In Drehgebern finden sich <span class="navy">optische, magnetische, induktive, kapazitive und resistiv-potenziometrische Sensorkerne</span>.</p>
<p>Weiterhin kann man nach <span class="navy">elektromechanischen</span> und <span class="navy">mechatronischen</span> Drehgebern unterscheiden. Bei elektromechanischen Drehgebern sind keine halbleitenden Elemente verbaut, wohl aber bei den mechatronischen. Bei den elektromechanischen Drehgebern stellt der Drehgeber nur den <span class="navy">Transducer</span> (dt.: Wandler) dar. Die auswertende Einheit steuert Sender und Empfänger und führt alle Maßnahmen zur Winkelauswertung durch. Bei einem mechatronischen Drehgeber hingegen geschieht dies alles geräteintern. Die aufbereitete Winkelinformation kann mit geringem Aufwand durch die auswertende Einheit verwendet werden.</p>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</section>
<section id="winkel-drehzahl-und-winkelbeschleunigung">
<h2>Winkel, Drehzahl und Winkelbeschleunigung<a class="headerlink" href="#winkel-drehzahl-und-winkelbeschleunigung" title="Link to this heading">¶</a></h2>
<p>Die Aufgabe von Drehgebern besteht darin die <span class="navy">Winkelstellung</span> einer rotatorischen Achse zu einem Referenzpunkt zu messen und anzuzeigen. Dabei wird nicht nur die eigentliche Winkelmessung betrachtet, sondern auch die Erfassung abgeleiteter Größen wie die Drehzahl und die Winkelbeschleunigung.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<a class="reference internal image-reference" href="../_images/winkelPhi.png"><img alt="../_images/winkelPhi.png" src="../_images/winkelPhi.png" style="width: 270px;" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
<section id="winkel">
<h3>Winkel<a class="headerlink" href="#winkel" title="Link to this heading">¶</a></h3>
<p>Für Winkel verwendet man die Einheiten <span class="navy">Grad</span> und <span class="navy">Radiant</span>. Dabei hat eine Umdrehung bekanntermaßen 360 Grad (Einheitszeichen °) oder im Bogenmaß, 2 <span class="math notranslate nohighlight">\(\pi\)</span> Radiant (Einheitszeichen rad). Die beiden Einheiten lassen sich mit dem Umrechnungsfaktor <span class="math notranslate nohighlight">\(\rho\)</span> einfach in Beziehung setzen:</p>
<p><span class="math notranslate nohighlight">\(\quad \rho = \frac{360°}{2\pi} = \frac{180°}{\pi}\)</span></p>
<p>Ein Grad lässt sich unterteilen in <span class="navy">Bogen- bzw. Winkelminuten</span> (1° = 60’) oder gar <span class="navy">Bogen- bzw- Winkelsekunden</span> (1’ = 60’’). Manchmal werden auch Milli-Grad (m°; <span class="math notranslate nohighlight">\(10^{-3}\)</span> °) verwendet. Eine Umdrehung (ein Vollwinkel) hat somit:</p>
<p>1 Umdrehung <span class="math notranslate nohighlight">\(\; \widehat{=}\)</span> 360° = 21.600’ = 1.296.000’’ = 360.000m°</p>
<p>Entsprechend ist eine Winkelsekunde annähernd der 1,3 Millionste Teil einer Umdrehung.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="winkelgeschwindigkeit">
<h3>Winkelgeschwindigkeit<a class="headerlink" href="#winkelgeschwindigkeit" title="Link to this heading">¶</a></h3>
<p>Neben dem eigentlichen Winkel sind auch daraus ableitbare Größen, wie z.B. die Winkelgeschwindigkeit bzw. <span class="navy">Drehzahl</span> für viele Anwendungen relevant.</p>
<p>Die Winkelgeschwindigkeit <span class="math notranslate nohighlight">\(\omega\)</span> bezeichnet die Änderung des Winkels mit der Zeit:</p>
<p><span class="math notranslate nohighlight">\(\quad \omega = \frac{d\varphi}{dt}\)</span></p>
<p>bzw. bei gleichförmiger Bewegung</p>
<p><span class="math notranslate nohighlight">\(\quad \omega = \frac{\Delta\varphi}{\Delta t}\)</span></p>
<p>Als Einheit für die Winkelgeschwindigkeit verwendet man <em>rad/s</em>, seltener <em>°/s</em>. In der Technik bezieht man sich oft auf die Anzahl der Umdrehungen pro Zeiteinheit, d.h. die Drehzahl (oder Umdrehungsfrequenz). Hierfür verwendet man die Einheit <span class="navy">Umdrehungen pro Minute</span> (<em>rpm</em>), 1/min oder <span class="math notranslate nohighlight">\({min}^{-1}\)</span> . Formal hat die Winkelgeschwindigkeit und die Drehzahl folgende Beziehung:</p>
<p><span class="math notranslate nohighlight">\(\quad n = \frac{30}{\pi} \cdot \omega = \frac{30}{\pi} \cdot \frac{\Delta\varphi}{\Delta t}\)</span></p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="winkelbeschleunigung">
<h3>Winkelbeschleunigung<a class="headerlink" href="#winkelbeschleunigung" title="Link to this heading">¶</a></h3>
<p>Die Winkelbeschleunigung <span class="math notranslate nohighlight">\(\alpha\)</span> beschreibt die Änderung  der Winkelgeschwindigkeit <span class="math notranslate nohighlight">\(\omega \;\)</span> mit der Zeit. Mathematisch ausgedrückt ergibt sich:</p>
<p><span class="math notranslate nohighlight">\(\quad  \alpha = \frac{d\omega}{dt} = \frac{d²\varphi}{dt²}\)</span></p>
<p>oder bei gleichförmiger Geschwindigkeitsänderung:</p>
<p><span class="math notranslate nohighlight">\(\quad  \alpha = \frac{\Delta\omega}{\Delta t} = \frac{\Delta² \varphi}{\Delta t²}\)</span></p>
<p>Bezogen auf die Drehzahl ergibt sich die folgende Beziehung:</p>
<p><span class="math notranslate nohighlight">\(\quad  \alpha = \frac{\pi}{30} \cdot \frac{\Delta n}{\Delta t}\)</span></p>
<p>Als Einheiten verwendet man <em>rad/s²</em>.</p>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;</section>
</section>
<section id="messbereich">
<h2>Messbereich<a class="headerlink" href="#messbereich" title="Link to this heading">¶</a></h2>
<p>Bei Drehgebern unterscheidet man primär drei Messbereiche: Teilwinkel, Vollwinkel oder mehrere Umdrehungen.</p>
<p>Stehen bei Drehgebern</p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &bull; &nbsp; <span style="font-size: 14px"> eindeutige Winkelwerte über <u>eine mechanische Umdrehung</u> zur Verfügung, spricht man von <b><font color =#000080>Singleturn-Drehgebern</font></b></span><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &bull; &nbsp; <span style="font-size: 14px"> eindeutige Winkelwerte über <u>mehrere Umdrehungen</u> zur Verfügung, spricht man von <b><font color =#000080>Multiturn-Drehgebern</font></b></span><br><div class="line-block">
<div class="line"><br /></div>
</div>
<a class="reference internal image-reference" href="../_images/turnTypes.png"><img alt="../_images/turnTypes.png" src="../_images/turnTypes.png" style="width: 517px;" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p><span class="under">Daneben gibt es zwei Sonderfälle zu betrachten:</span></p>
<p><span class="navy">Inkrementalgeber</span> zeigen nur eine Winkeländerung (Inkremente) gemäß deren Auflösung an. Diese Funktion steht über eine Umdrehung zur Verfügung.</p>
<p><span class="navy">Rundachsfunktion</span> (Endloswelle, elektronisches Getriebe) - Drehgeber zeigen einen anderen Messbereich an als den, der der verwendeten Sensorik zugrunde liegt. Die Rundachsfunktion erlaubt ganzzahlige und nicht-ganzzahlige Über-und Untersetzungsverhältnisse (s.Bild oben).</p>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;</section>
<section id="winkelberechnung">
<h2>Winkelberechnung<a class="headerlink" href="#winkelberechnung" title="Link to this heading">¶</a></h2>
<p>Nur wenige Drehgeber erlauben es, einen winkelproportionalen Wert direkt sensorisch zu ermitteln (z.B. resistiv-potentiometrischer Drehgeber). Bei den anderen Prinzipien wird versucht einen in der Mathematik üblichen Weg zu gehen: <span class="navy">Der Winkel wird auf Basis trigonometrischer Funktionen ermittelt</span>. Die Sensoren werden so gestaltet, dass bei Drehbewegung sinusförmige Signale entstehen, meist ein <span class="navy">Sinus- und ein Cosinussignal</span> (s. Bild unten). Diese Signalpaarung wird auch als Quadratursignale bezeichnet, da sie in Quadratur, d.h. im rechten Winkel stehen (90° Phasenversatz).</p>
<p>Zur Veranschaulichung kann eine Darstellung am Einheitskreis verwendet werden. Ein Zeiger (Vektor) mit der Länge 1 dreht sich gegen den Uhrzeigersinn. Als Drehachse ist der Koordinatenursprung definiert und als Nullpunkt die Lage des Zeigers auf der Abszisse in positiver Richtung liegend. Die <span class="navy">y-Komponente des Zeigers repräsentiert den Sinus</span> und die <span class="navy">x-Komponente den Cosinus.</span> Der Winkel <span class="math notranslate nohighlight">\(\varphi\;\)</span> wird zwischen dem Vektor und der Abszisse aufgespannt.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<a class="reference internal image-reference" href="../_images/unitCircle.png"><img alt="../_images/unitCircle.png" src="../_images/unitCircle.png" style="width: 512px;" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Diese Sinus- und Cosinussignale lassen sich anhand der bekannten trigonometrischen Beziehung</p>
<p><span class="math notranslate nohighlight">\(\quad \tan\varphi = \frac{\sin\varphi}{\cos\varphi}\)</span></p>
<p>wie folgt in einen Winkel umrechnen:</p>
<p><span class="math notranslate nohighlight">\(\quad \varphi = \arctan(\frac{a_{sin}}{a_{cos}})\)</span></p>
<p>( <span class="math notranslate nohighlight">\(\varphi\)</span> : Errechneter Winkel in [°];     <span class="math notranslate nohighlight">\(a_{sin}, a_{cos}\)</span> : Momentanwerte der Sinus- und Cosinussignale)</p>
<p>Die Gleichung bezieht sich auf eine Sinus-Cosinus-Signalperiode. Hat ein Drehgeber eine solche Signalperiode pro Umdrehung, so ergibt sich direkt die Winkelstellung des Rotors zum Stator. Da in der praktischen Umsetzung die Sinus- und Cosinussignale und somit der sich ergebende Winkel nicht unendlich hoch aufgelöst werden können, Anwendungen aber hohe Auflösungen fordern, <span class="navy">unterteilt man den Vollwinkel in mehrere Teilwinkel</span>. Dabei wird jeder Teilwinkel durch eine Signalperiode repräsentiert, man rechnet also mit mehreren Perioden pro Umdrehung (engl.: „periods per revolution”, PPR). Dies wird dargestellt durch:</p>
<p><span class="math notranslate nohighlight">\(\quad \varphi_i = \frac{1}{\text{PPR}} \arctan\frac{a_{sin}}{a_{cos}} \quad\quad\quad\quad\quad (1.1)\)</span></p>
<p>( <span class="math notranslate nohighlight">\(\varphi_i\)</span> : Momentanwert des Winkels der i-ten Periode in [°];     PPR: Anzahl der Periode pro Umdrehung; <span class="math notranslate nohighlight">\(\; a_{sin}, a_{cos}\)</span> : Momentanwerte der Sinus- und Cosinussignale)</p>
<p>Durch diese Beziehung kann man zwar die Auflösung erhöhen, verliert aber die Aussage über einen absoluten Winkel auf eine Umdrehung. Es ist daher nun sinnvoll <span class="math notranslate nohighlight">\(\varphi_{elektr}\)</span> und <span class="math notranslate nohighlight">\(\varphi_{mech}\)</span> einzuführen. <span class="math notranslate nohighlight">\(\varphi_{elektr}\)</span> bezeichnet <span class="navy">einen Winkel innerhalb einer elektrischen Periode</span> und <span class="math notranslate nohighlight">\(\varphi_{mech}\)</span> jenen auf <span class="navy">eine mechanische Umdrehung</span>.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<a class="reference internal image-reference" href="../_images/ppr.png"><img alt="../_images/ppr.png" src="../_images/ppr.png" style="width: 514px;" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Neben der reinen Winkelrechnung kann auf Basis der sinusförmigen Signale auch eine einfache <span class="navy">Überprüfung der Funktion des Drehgebers</span> durchgeführt werden. Geben Drehgeber direkt sinusförmige Signale an der elektrischen Schnittstelle aus, kann die bekannte goniometrische Beziehung <span class="math notranslate nohighlight">\(\sin²+\cos² = 1\)</span> interpretiert werden als:</p>
<p><span class="math notranslate nohighlight">\(\quad a^2_{sin} + a^2_{cos} = \text{const}\)</span></p>
<p>Das Ergebnis wird auch als Vektorlänge bezeichnet. Diese ist in vielen Belangen von hoher Bedeutung.</p>
<p>Eine weitere Möglichkeit, die sich durch die Verwendung von Sinus- und Cosinussignalen ergibt ist die der Lissajous-Figur. Mit einem Oszilloskop in xy-Darstellung zeichnen die sinusförmigen Signale bei Drehung eine kreisähnliche Form (ein Kreis bei idealen Sinus-Cosinus-Signalen). Der Einheitskreis wird dadurch messtechnisch dargestellt. Auf diese Weise lassen sich verschiedene Qualitätsmerkmale der Quadratursignale abschätzen. Dies ist ein einfach umzusetzendes indikatives Verfahren.</p>
<p>Die eigentliche Winkelrechnung basiert auf Gl. 1.1 (s.oben) wird in diesem Zusammenhang als <span class="navy">Interpolation</span> bezeichnet. Interpolatoren können in zwei Dimensionen auf unterschiedliche Weise umgesetzt werden. Zum einen gibt es
verschiedene Verfahren und zum anderen verschiedene Integrationsstufen in der Umsetzung in Hardware und Software. <span class="navy">Sinus/Cosinus-Digital-Wandler</span> (engl.:„sine/cosine-to-digital converter”; SDC), wie Interpolatoren auch genannt werden, gibt es als dedizierte ASIC- oder ASSP-Komponenten. Auch kann die Funktion nach Digitalisierung der sinusförmigen Signale durch geeignete Analog-Digital-Wandler mittels Software auf Mikrocontrollern, digitalen Signalprozessoren (DSPs) oder FPGAs implementiert werden. Dabei wird oft der sogenannte CORDIC Algorithmus (engl.: „coordinate rotation digital computer”) für die Berechnung der trigonometrischen Funktionen eingesetzt.</p>
<p><span class="under">Bei den Verfahren sollen drei mögliche genannt werden:</span></p>
<p><span class="navy">[1]</span> Der klassische Ansatz ist es <span class="navy">die Sinus- und Cosinus-Signale gleichzeitig mit linearen Analog-Digital-Wandlern abzutasten</span> und die digitalen Werte gemäß Gl. 1.1 in einen Winkel umzurechnen. Alternativ kann der Winkelwert aus einer zweidimensionalen Matrix ausgelesen werden, wobei die digitalen Sinus- und Cosinuswerte die Indizes für die Reihen und Spalten darstellen. Vor der Winkelwandlung können die Digitalwerte normiert (z. B. Amplitude) und hinsichtlich Fehlerkomponenten (z. B. Offset) korrigiert werden.</p>
<p><span class="navy">[2]</span> Ein <span class="navy">Flash-SDC</span> ist vergleichbar einem linearen Flash Analog-Digital-Wandler. Bei diesen wird das Eingangssignal mit mehreren Referenzspannungen durch analoge Komparatoren verglichen. Für jeden aufgelösten Schritt wird ein Komparator benötigt. Die Referenzspannungen werden aus einer Spannung durch eine Kaskade von Widerständen gebildet. Beim Flash-SDC werden im Gegensatz dazu zwei Eingangssignale zugeführt und die Widerstandskaskade ist so ausgelegt, dass die Komparatoren Winkelwerte zugeordnet werden. Flash-SDCs sind sehr schnell, der Hardwareaufwand lässt sich allerdings nur für geringe Auflösungen sinnvoll umsetzen.</p>
<p><span class="navy">[3]</span> Interpolatoren die mit dem <span class="navy">Nachlaufverfahren</span> arbeiten, schätzen einen Winkel aus den Signalen ab und führen das Ergebnis auf den Eingang zurück. Dort wird eine Differenz ermittelt, die solange nachgeregelt wird, bis der Fehler minimal wird. Diese Regelung geschieht sehr schnell, insbesondere wenn ein Winkel ermittelt wurde und dieser nur nachgeführt werden muss.</p>
<p>Die verschiedenen Verfahren unterscheiden sich, u. a. im <strong>Implementierungsaufwand</strong> (Hard- und/oder Software), in der <strong>Schnelligkeit</strong> (somit durch Wandlung eingeführte Latenz), <strong>Auflösung</strong> und <strong>Genauigkeit</strong>.</p>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;</section>
<section id="kodierung">
<h2>Kodierung<a class="headerlink" href="#kodierung" title="Link to this heading">¶</a></h2>
<p>Ein Sinus- Cosinus-Signalpaar wird dazu verwendet, einen Winkel innerhalb einer elektrischen Periode darzustellen. Dies ist für industrielle Anwendungen meist
nicht ausreichend. Es werden Konventionen und Zusatzinformationen zur Gewinnung der Absolutinformation eingeführt. Es ergeben sich Codes, die innerhalb des Drehgebers oder durch eine Steuerung weiter verarbeitet werden können. Dabei unterscheidet man <span class="navy">Inkrementalcodes</span>, die eine Winkeländerung anzeigen, von <span class="navy">Absolutcodes</span>, die zu jeder Zeit einen eindeutigen Winkel innerhalb des Messbereichs zur Verfügung stellen.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<section id="inkrementalcode">
<h3>Inkrementalcode<a class="headerlink" href="#inkrementalcode" title="Link to this heading">¶</a></h3>
<p>Bei Drehgebern mit Inkrementalcode (Inkrement als Elementarschritt oder abzählbares Intervall) wird die Winkelinformation relativ ausgegeben. Das heißt, es wird nicht die absolute Winkelinformation, sondern nur eine <span class="navy">Winkeländerung</span> mittels Signaländerungen angezeigt. Es werden zwei Signalarten genutzt: rechteck- und sinusförmige Signale.</p>
<p>Bei den inkrementalen Drehgebem mit Rechtecksignalen wird in der einfachsten Form ein einziges Signal zur Verfügung gestellt (Bild unten, links). Dieses Signal
erlaubt nur die Ermittlung einer Winkeländerung anhand der Auswertung der Signalflanken. Erweitert man das System um ein zweites, um 90° phasenverschobenes Signal, erhält man ein Quadratursignalpaar. Die Signale dieses Paares werden mit unterschiedlichen Buchstabenkombinationen bezeichnet. Hier werden die Buchstaben <em>A</em> und <em>B</em> verwendet. Bezieht man sich auf die Signalpaarung, so kann die Bezeichnung <em>AqB</em> verwendet werden. Mit <em>AqB</em> kann man zusätzlich zur Winkeländerung die <span class="navy">Drehrichtung</span> erkennen (Bild unten, oben rechts). Hierzu werden zusätzlich zu den Signalflanken die Signalpegel ausgewertet. Gleichzeitig wird bei gleicher Anzahl an Impulsen pro Signal pro Umdrehung die Auflösung verdoppelt. Um die Zuordnung zu einem Bezugspunkt auf dem Vollwinkel zu erhalten, kann ein drittes Signal, zur Verfügung gestellt werden, der sogenannte Nullimpuls - hier Signal Z (Bild unten, oben rechts). Dieser Nullimpuls schaltet einmalig pro Umdrehung und hat eine definierte Lage und Dauer in Bezug auf die Inkrementalsignale A und B (eine eingeschränkte Anzahl von Relationen wird verwendet). Dadurch kann eine quasi-absolute Position ermittelt werden. Allerdings muss eine sogenannte Referenzfahrt beim Einschalten des Drehgebers durchgeführt werden, um diesen Bezugspunkt einmalig zu durchfahren. Durch Zählen der Inkrementalsignale kann eine pseudo-absolute Position (Single- oder gar Multiturn) nachgehalten werden.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<a class="reference internal image-reference" href="../_images/inkrement.png"><img alt="../_images/inkrement.png" src="../_images/inkrement.png" style="width: 502px;" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>In der realen Umsetzung erhält man keine perfekten Rechtecksignale direkt aus der Sensorik. Meist erhält man verschliffene, dreieckförmige oder sinusförmige Signale. Für gut schaltende Rechtecksignale, werden diese anhand eines Komparators aufbereitet. Natürlich werden aber auch die sinusförmigen Signale in Inkrementaldrehgebern verwendet (Bild oben, unten). Da Steuerungen, die für Inkrementalgeber ausgelegt sind, rechteckförmige Signale erwarten, werden die Sinus-Cosinus-Signale aufbereitet. Dazu kann auch die Interpolation verwendet werden, wodurch auch die Auflösung erhöht wird.</p>
<p>Die Abbildung unten zeigt die Codescheibe eines optischen Inkrementalgebers. Die randnah gestrichelte Struktur besteht aus regelmäßigen, (Rechtecke polar aufgetragen) lichtdurchlässigen und -undurchlässigen Bereichen zur Generierung der AqB-Signale. Die rechteckförmige Struktur über der “500”-Kennzeichnung dient zur Generierung des Nullimpulses.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<a class="reference internal image-reference" href="../_images/codescheibe.png"><img alt="../_images/codescheibe.png" src="../_images/codescheibe.png" style="width: 299px;" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Ein Nebenaspekt hochauflösender optischer Drehgeber, in deren Ausprägung als Inkrementalgeber mit rechteckförmigen Signalen, ist, dass ihre Leistungsfähigkeit nur unwesentlich durch äußere Bedingungen, wie beispielsweise Temperatur, beeinflusst wird. Die hohe native Auflösung, die physikalisch in der Maßverkörperung vorliegt, reduziert erheblich den Einfluss von signalperiodenbezogenen Fehlern wie Offset- und/oder Amplitudenänderungen.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="absolutcode">
<h3>Absolutcode<a class="headerlink" href="#absolutcode" title="Link to this heading">¶</a></h3>
<p>Genügt es bei einer Anwendung nicht, dass nur Winkeländerungen oder Winkel innerhalb eines Teilwinkels (z. B. eine elektrische Periode) angezeigt werden, sondern zu jeder Zeit eine absolute Winkelposition auf eine Umdrehung (oder mehrere Umdrehungen) zur Verfügung steht, kommen <span class="navy">Absolutdrehgeber</span> zum Einsatz. Dies ist insbesondere dann wichtig, wenn die Absolutposition beim Einschalten des Drehgebers zur Verfügung stehen muss, da auf eine Referenzfahrt anwendungsbedingt verzichtet werden muss. Der Begriff Absolutposition bezieht sich eher auf eine lineare Position wird aber auch bei Drehgebern zur Angabe eines absoluten Winkels verwendet.</p>
<p>Absolutdrehgeber verwenden eine Kombination aus einer mehr oder weniger hoch aufgelösten Inkrementalspur und weiteren Signalspuren. Diese Zusatzinformation wird dazu genutzt den elektrischen Perioden der Inkrementalspur (sinus- oder rechteckförmig) einen Index zuzuweisen. Die Signale zusammen genommen realisieren einen Code, der von der Maßverkörperung getragen wird. Zum Einsatz kommen, z. B. Binär-, Gray-, Nonius- oder Pseudo-Random-Codes.</p>
<p>Der einfachste Code ist der <span class="navy">Binärcode</span>. Die Signale werden als Rechtecksignale gelesen, wobei jede Signalspur ein Bit eines binären Codes darstellt. Es werden zwei Arten von Code benutzt. Beim klassischen Binärcode stellt das gelesene Codewort direkt den Winkel dar (Bild unten, oben). Bei Drehgebern verwendet man allerdings
bevorzugt den <span class="navy">Gray-Code</span> (Bild unten, unten). Dies ist ein stetiger Code mit der spezifischen Eigenart, dass sich beim Übergang von einem auflösbaren Schritt zum nächsten, jeweils nur ein Bit ändert. Es entsteht kein „Winkelprellen” beim Übergang von einem Codewort zum nächsten. Ein möglicher Ablesefehler beträgt maximal eins.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<a class="reference internal image-reference" href="../_images/codes.png"><img alt="../_images/codes.png" src="../_images/codes.png" style="width: 583px;" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Der Nachteil der Binärcodes ist, dass jedes Datenbit in einer dedizierten Codespur codiert werden muss. Dies führt zu einem großen radialen Platzbedarf bei großen
Codebreiten. Des Weiteren kann es auch schwierig sein den Sensor zu gestalten. So muss bei optischen Drehgebern eine relativ große Fläche homogen ausgeleuchtet
werden. Für magnetische Drehgeber gar wäre es eine große Herausforderung eine entsprechende Codescheibe zu magnetisieren. Nonius- und Pseudo-Random-Codes begegnen diesem Problem, da sie mit weniger Codespuren zur Darstellung eines absoluten Drehgebercodes auskommen.</p>
<p>Der <span class="navy">Nonius-Code</span> (oder <em>Vernier</em> - Code) ist aus der Anwendung beim Messschieber bekannt. Bei diesem Code werden eine Hauptskala (hier bezeichnet mit <em>m</em>) und eine oder mehrere Teilskalen ( <span class="math notranslate nohighlight">\(n_i\)</span> ) miteinander verrechnet. In der typischen Verwendung des Codes in Drehgebern haben die Spuren eine um eins unterschiedliche Anzahl von Perioden pro Umdrehung ( <span class="math notranslate nohighlight">\(m = n+l\)</span> ). Bei der Wahl der Teilungsperioden muss auf das Auflösevermögen des Systems geachtet werden. Es können nicht beliebig große Teilungen verwendet werden, da diese irgendwann nicht mehr eindeutig erfasst und verrechnet werden können. Werden mehr als zwei Codespuren verwendet, lassen sich größere, oder höher aufgelöste Messbereiche realisieren. Die Gl. (1.2) stellt die Verrechnung eines zweispurigen Nonius-Codes dar (s.Bilder unten).</p>
<div class="math notranslate nohighlight">
\[\varphi = \frac{1}{m - n} \, \left( \arctan \left( \frac{\sin{m\varphi}}{\cos{m\varphi}} \right) - \arctan \left( \frac{\sin{n\varphi}}{\cos{n\varphi}} \right) \right) \quad\quad\quad\quad  (1.2)\]</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Sonderformen des Nonius-Codes verwenden Skalen, deren Periodenlänge sich um mehr als eine Periode unterscheiden. Auch bei diesen Codes kann man den Absolutwinkel mit Gl. (1.2) berechnen. Zu beachten ist, dass die beiden Faktoren keinen gemeinsamen Teiler haben, da sonst die Eindeutigkeit auf eine Umdrehung verloren geht. Auch mit diesem als <em>MxN</em> bezeichneten Code kann ein recht großer Messbereich erfasst werden. Der MxN-Code wird bei Drehgebern eingesetzt, bei denen es sinnvoll ist, sehr unterschiedliche Periodenlängen in den Codespuren zu verwenden. Außerdem ist er weniger empfindlich auf mechanische Toleranzen (Bild unten).</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<a class="reference internal image-reference" href="../_images/nonius.png"><img alt="../_images/nonius.png" src="../_images/nonius.png" style="width: 490px;" /></a>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<a class="reference internal image-reference" href="../_images/miscCodes.png"><img alt="../_images/miscCodes.png" src="../_images/miscCodes.png" style="width: 498px;" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Der <span class="navy">Pseudo-Random-Code [3, 4]</span> ist ein einspuriger Absolut-Code, der ebenfalls parallel zu einer Inkrementalspur verwendet werden kann. Er ist so gestaltet, dass er sequentiell ausgelesen wird. Für einen <span class="math notranslate nohighlight">\(2^x\)</span> -Code wird ein Abtaster mit mindestens x Ausleseelementen tangential zur Drehachse aufgebracht. Jeder Winkelschritt stellt ein eindeutiges Codewort dar, das mittels eines passenden Dekodierpolynoms dekodiert werden kann. Die Besonderheit bei diesem Code ist, dass er in sich geschlossen ist, d. h. das letzte Codewort geht nahtlos in das erste über, was für Drehgeber natürlich sehr günstig ist (Bild unten).</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<a class="reference internal image-reference" href="../_images/randomCode.png"><img alt="../_images/randomCode.png" src="../_images/randomCode.png" style="width: 514px;" /></a>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;</section>
<section id="synchronisation">
<h3>Synchronisation<a class="headerlink" href="#synchronisation" title="Link to this heading">¶</a></h3>
<p>Immer dann, wenn ein Messwert aus mehreren Teilmessungen zusammengesetzt wird, ist es sinnvoll <span class="navy">die einzelnen Teilmesswerte zueinander zu synchronisieren</span>. Dies gilt insbesondere dann, wenn die Teilmessungen durch unterschiedliche, unabhängige Sensoren erfasst werden. Beispiele hierfür sind die Kombination einer Inkrementalspur mit einem Pseudo-Random-Code, die Übertragung eines Positionswerts über eine hybride Schnittstelle (niedrig aufgelöster Absolutwert auf einem digitalen Kanal und hochaufgelöste Information innerhalb einer Sinus-Cosinus-Periode als analoges Signal) oder bei der Kaskadierung mehrerer Multiturn-Stufen untereinander und mit einer Singleturn-lnformation. Problematisch ist, dass die Ergebnisse der Teilmessungen unterschiedliche Schaltzeiten aufweisen können. Dies kann bedingt sein durch Signallaufzeiten, Getriebespiel bei einem getriebebasierten Multiturn, Hysterese, Signalrauschen, etc.. Wenn keine Maßnahmen getroffen werden, kann die Stetigkeit der Gesamtinformation verloren gehen. Die Synchronisation beschreibt nun ein Verfahren mit dem diesem Phänomen begegnet werden kann.</p>
<p>Die Synchronisation wird bei digitalisierten Werten der Teilmessungen verwendet. Entsprechend lässt sich auch das Verfahren anhand von digitalen Codeworten am einfachsten beschreiben. In der Abbildung unten wird ein System beispielhaft angeführt, das seine Positionsinformation aus zwei Teilmessungen bildet. Dabei stellt die eine Teilmessung einen interpolierten Wert einer elektrischen Periode (Feinposition) dar und die zweite einen Absolutwert auf eine mechanische Umdrehung. Im oberen Teil schließen die Datenwörter der beiden Teilmessungen direkt aneinander an. <span class="navy">Schaltet nun der Absolutwert nicht in exakt dem Moment um in dem die Feinposition von einer Periode zur nächsten wechselt, so zeigt der Absolutwert einen falschen Periodenindex an, es kommt zu einem irregulären Positionssprung</span>. Dieser wird erst wieder aufgehoben, wenn der Absolutwert in die richtige Periode zeigt. Dieser Positionssprung kann dadurch behoben werden, dass die Absolutposition feiner aufgelöst wird, d.h. der Absolutwert repräsentiert nicht nur die Anzahl der Perioden, sondern trägt noch Information innerhalb einer Periode. In dem Beispiel in der Abbildung unten werden zwei Synchronisationsbits eingeführt. Diese werden so ausgelegt, dass sie die gleiche Wertigkeit haben wie die entsprechenden hochwertigen Bits der Feinposition. Bei der Inbetriebnahme eines Geräts werden diese so festgelegt, dass die überlappenden Bits den gleichen Wert haben. Unterschiede im Wechselverhalten können nun ausgeglichen werden. Weisen die Bits unterschiedliche Werte auf wird eine Differenz gebildet und das Datenwort des Absolutwerts so gesetzt, dass es in die Richtung der kleineren Differenz liegt. Je mehr Synchronisationsbits verwendet werden, desto sicherer funktioniert das Verfahren. Dies bringt aber einen größeren Umsetzungsaufwand mit sich.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<a class="reference internal image-reference" href="../_images/syncMes.png"><img alt="../_images/syncMes.png" src="../_images/syncMes.png" style="width: 499px;" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
</section>
</section>


	    </div>
            <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../grundlagen/labview.html" class="btn btn-neutral float-right" title="LabView">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../motoren/weitMot.html" class="btn btn-neutral" title="Weitere Motortypen"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2024, Hautaklyttn.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/jucacrispim/sphinx_pdj_theme">theme</a> provided by <a href="https://poraodojuca.dev">Porão do Juca</a>.

</footer>
	</div>
	</div>
	  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
    <script type="text/javascript" src="../_static/documentation_options.js">

    </script>
    <script type="text/javascript" src="../_static/doctools.js">

    </script>
    <script type="text/javascript" src="../_static/sphinx_highlight.js">

    </script>
    <script type="text/javascript" src="../_static/mathJax_v3.js">

    </script>

  

   <script type="text/javascript"
           src="../_static/js/theme.js"></script>

   <script type="text/javascript"
           src="../_static/js/pdj.js"></script>

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

  </body>
</html>